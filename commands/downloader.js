const { tlang, ringtone, cmd,fetchJson, sleep, botpic, getBuffer, pinterest, prefix, Config, citel } = require('../lib')
const { mediafire } = require("../lib/mediafire.js");
const googleTTS = require("google-tts-api");
const ytdl = require('ytdl-secktor')
const fs = require('fs-extra')
var videotime = 60000 // 1000 min
var dlsize = 440 // 440mb
    //---------------------------------------------------------------------------
cmd({
            pattern: "tts",
            react: "üéôÔ∏è",
            desc: "text to speech.",
            category: "downloader",
            filename: __filename,
            use: '<Hii,this is Secktor>',
        },
        async(Void, citel, text) => {
            if (!text) return citel.reply('Please give me Sentence to change into audio.')
            let texttts = text
            citel.react("üì¢");
            const ttsurl = googleTTS.getAudioUrl(texttts, {
                lang: "en",
                slow: false,
                host: "https://translate.google.com",
            });
           const txt = await Void.sendMessage(citel.chat, {
                audio: {
                    url: ttsurl,
                },
                mimetype: "audio/mpeg",
                fileName: `ttsiCitelVoid.m4a`,
            }, {
                quoted: citel,
            });
            
            await Void.sendMessage(citel.chat, { react: {
        text: "üéº",
        key: txt.key,
            } } )
        }

    )
    
    //---------------------------------------------------------------------------
cmd({
            pattern: "ttsi",
            desc: "text to speech.",
            category: "downloader",
            filename: __filename,
            use: '<‡∑Ñ‡∑è‡∂∫‡∑í,‡∂ö‡∑ú‡∑Ñ‡∑ú‡∂∏ ‡∂Ø ‡∂î‡∂∫‡∑è‡∂ß ?>',
            react: "üéôÔ∏è",
        },
        async(Void, citel, text) => {
            if (!text) return citel.reply('Please give me Sentence to change into audio.')
            let texttts = text
            citel.react("üì¢");
            const ttsurl = googleTTS.getAudioUrl(texttts, {
                lang: "si",
                slow: false,
                host: "https://translate.google.com",
            });
            const txt = await Void.sendMessage(citel.chat, {
                audio: {
                    url: ttsurl,
                },
                mimetype: "audio/mpeg",
                fileName: `ttsiCitelVoid.m4a`,
            }, {
                quoted: citel,
            });
            
            await Void.sendMessage(citel.chat, { react: {
        text: "üéº",
        key: txt.key,
            } } )
            
        }

    )
    //---------------------------------------------------------------------------
cmd({
            pattern: "videolist",
            desc: "Downloads video from yt.",
            category: "downloader",
            filename: __filename,
            use: '<faded-Alan Walker>',
        },
        async(Void, citel, text) => {
            if (!text) return citel.reply(`Example : ${prefix}audio Back in black`)
            let yts = require("secktor-pack")
            let search = await yts(text)
            listSerch = []
            teskd = `\nResult got from ${text}.\n`
            for (let i of search.all) {
                listSerch.push({
                    title: i.title,
                    rowId: `${prefix}ytmp4 ${i.url}`,
                    description: `Dragon / ${i.timestamp}`
                })
            }
            const sections = [

                {
                    title: "Total Searchüîç" + search.all.length,
                    rows: listSerch
                }

            ]
            const listMessage = {
                text: teskd,
                footer: tlang().footer,
                title: ` *Youtube Search results by  ${tlang().title}.*`,
                buttonText: "Videos",
                mentions: await Void.parseMention(teskd),
                sections
            }
            return Void.sendMessage(citel.chat, listMessage, {
                quoted: citel
            })

        }
    )
    //---------------------------------------------------------------------------
cmd({
            pattern: "play",
            alias: ["‡∑É‡∑ú‡∂∫‡∂±‡∑ä‡∂±",".ytsearch"],
            desc: "Sends info about the query(of youtube video/audio).",
            category: "downloader",
            react: "üé¶",
            filename: __filename,
            use: '<faded-Alan walker.>',
        },
async(Void, citel, text) => {
        let yts = require("secktor-pack");

            let search = await yts(text);

            let anu = search.videos[0];
        const getRandom = (ext) => {
            return `${Math.floor(Math.random() * 10000)}${ext}`;
        };

        if (text.length === 0) {
            reply(`‚ùå URL is empty! \nSend ${prefix}ytmp3 url`);
            return;
        }
        try {
            let urlYt = text;
            if (!urlYt.startsWith("")) {
                citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}song [name or link]_`);
                return;
            }
            let infoYt = await ytdl.getInfo(anu.url);
            //30 MIN
            if (infoYt.videoDetails.lengthSeconds >= videotime) return citel.reply(`*The limit has been exceeded.*‚ùó`);
            let titleYt = infoYt.videoDetails.title;
            let randomName = getRandom(".mp3");
            const stream = ytdl(anu.url, {
                    filter: (info) => info.audioBitrate == 160 || info.audioBitrate == 128,
                })
                .pipe(fs.createWriteStream(`./${randomName}`));
            await new Promise((resolve, reject) => {
                stream.on("error", reject);
                stream.on("finish", resolve);
            });

            let stats = fs.statSync(`./${randomName}`);
            let fileSizeInBytes = stats.size;
            let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
            if (fileSizeInMegabytes <= dlsize) {
                let yts = require("secktor-pack");
           const txt = await Void.sendMessage(citel.chat, {image: {url: anu.thumbnail}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üéûÔ∏è YT DOWNLOADER üé∂_ )* \n\n*‚îÉ‚øª* *üéß ·¥Ä·¥ú·¥Ö…™·¥è ·¥õ…™·¥õ ü·¥á :* ${anu.title}\n\n*‚îÉ‚øª* *‚è≥ ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :* ${anu.timestamp}\n\n*‚îÉ‚øª* üóÉÔ∏è *Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB\n\n*‚îÉ‚øª* *üëÄ Ô∏è·¥†…™·¥á·¥°Íú± :* ${anu.views}\n\n*‚îÉ‚øª* *üëç  ü…™·¥ã·¥áÍú± :* ${anu.like}\n\n*‚îÉ‚øª* *‚è∞ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥õ…™·¥ç·¥á :* ${anu.ago}\n\n*‚îÉ‚øª* *üóÉÔ∏è ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è :* ${anu.genre}\n\n*‚îÉ‚øª* *üñáÔ∏è ·¥†…™·¥Ö·¥á·¥è  ü…™…¥·¥ã :* ${anu.url}\n\n*‚îÉ‚øª* *üìπ  è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* ${anu.author.name}\n\n*‚îÉ‚øª* *üìé ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™…¥·¥ã :* ${anu.author.url}\n\n*‚îÉ‚øª* *üì∞ ·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :* ${anu.description}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*`}, { quoted: citel });

        await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt.key,
            } } )

                let search = await yts(text);
                let buttonMessage = {
                        document: fs.readFileSync(`./${randomName}`),
                        jpegThumbnail: log0,
                        mimetype: 'audio/mpeg',
                        fileName: `${titleYt}.mp4`,
                                                caption: `_*‚ùÇ  ·¥Ä·¥ú·¥Ö…™·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB_\n_*‚ùÇ  ·¥Ä·¥ú·¥Ö…™·¥è «´·¥ú·¥Ä ü…™·¥õ è :* 128 kbps_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,
                        headerType: 4,
                    }
            await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt.key,
            } } )
        
            const txt2 = await Void.sendMessage(citel.chat, buttonMessage, { quoted: citel })
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "üé∂Ô∏è",
        key: txt.key,
            } } )
 
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt.key,
            } } )
                                        
                    await Void.sendMessage(citel.chat, { react: {
        text: "üéß",
        key: txt2.key,
            } } )

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt.key,
      } } )

const apis = await fetchJson(`https://gist.githubusercontent.com/TechwithAmee1/a88de5b36f9d08470149f87fcbaf76fd/raw/15608e9ba09e2fd539738f426049caf2ecefb0a2/data.js`)

const ytdweb = await fetchJson(`https://api-fgmods.ddns.net/api/dowloader/ytdl?url=${anu.url}&apikey=${apis.fgapi}`)

const downloadlink = ytdweb.result.mp4.result
const filesize = ytdweb.result.mp4.size
const vidq = ytdweb.result.mp4.quality

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt.key,
      } } )

                let buttonMessage2 = {

                        document: {

                             url: downloadlink ,

                            },

                        jpegThumbnail: log0,

                        mimetype: 'video/mp4',

                        fileName: `${titleYt}.mp4`,

                        caption: `_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è «´·¥ú·¥Ä ü…™·¥õ è :* ${vidq}_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${filesize}_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,

                        headerType: 4,

                    }


            const txt3 = await Void.sendMessage(citel.chat, buttonMessage2, { quoted: citel })
   
                    await Void.sendMessage(citel.chat, { react: {
        text: "üéûÔ∏è",
        key: txt.key,
            } } )

        await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt.key,
            } } )

        await Void.sendMessage(citel.chat, { react: {
        text: "üé•Ô∏è",
        key: txt3.key,
            } } )

                } else {
                   const txt4 = await citel.reply(`*The limit has been exceeded.*‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )
                }

                fs.unlinkSync(`./${randomName}`);
            } catch (e) {
                console.log(e)
            }
        }
    )

  //---------------------------------------------------------------------------

cmd({
            pattern: "ringtone",
            desc: "Downloads ringtone.",
            category: "downloader",
            filename: __filename,
            use: '<ringtone name>',
            react: "üì≥",
        },
        async(Void, citel, text) => {
            if (!text) return citel.reply(`Example: ${prefix}ringtone back in black`)
            let anu = await ringtone(text)
            let result = anu[Math.floor(Math.random() * anu.length)]
            return Void.sendMessage(citel.chat, { audio: { url: result.audio }, fileName: result.title + '.mp3', mimetype: 'audio/mpeg' }, { quoted: citel })
        }
    )
    //---------------------------------------------------------------------------
cmd({
            pattern: "pint",
            desc: "Downloads image from pinterest.",
            category: "downloader",
            filename: __filename,
            use: '<text|image name>',
            react: "üñºÔ∏è",
        },
        async(Void, citel, text) => {
            if (!text) return reply("What picture are you looking for?") && Void.sendMessage(citel.chat, {
                react: {
                    text: '‚ùó',
                    key: citel.key
                }
            })
            try {
                anu = await pinterest(text)
                result = anu[Math.floor(Math.random() * anu.length)]
                let buttonMessage = {
                    image: {
                        url: result
                    },
                    caption: ` `,
                    footer: tlang().footer,
                    headerType: 4,
                    contextInfo: {
                        externalAdReply: {
                            title: `Here it is‚ú®`,
                            body: `${Config.ownername}`,
                            thumbnail: log0,
                            mediaType: 2,
                            mediaUrl: ``,
                            sourceUrl: ``
                        }
                    }
                }
                return Void.sendMessage(citel.chat, buttonMessage, {
                    quoted: citel
                })
            } catch (e) {
                console.log(e)
            }
        })
    //---------------------------------------------------------------------------
cmd({
            pattern: "mediafire",
            desc: "Downloads zip from Mediafire.",
            react: "üóÇÔ∏è",
            category: "downloader",
            filename: __filename,
            use: '<url of mediafire>',
        },
        async(Void, citel, text) => {
            if (!text) return citel.reply(`Give link ${tlang().greet}`);
            let urlYt = text;
            if (!urlYt.startsWith("http")) {
                citel.reply(`‚ùå Give youtube link!`);
                                return;

            }
            
            const apis = await fetchJson(`https://gist.githubusercontent.com/TechwithAmee1/a88de5b36f9d08470149f87fcbaf76fd/raw/15608e9ba09e2fd539738f426049caf2ecefb0a2/data.js`)
            
            const mediafire = await fetchJson(`https://api-fgmods.ddns.net/api/dowloader/mediafire?url=${text}&apikey=${apis.fgapi}`)
            const res = mediafire.result

            let fileSizeInBytes = res.filesize;
            let fileSizeInMegabytes = fileSizeInBytes / (1000);
            if (fileSizeInMegabytes <= dlsize) {

const thumb = await fetchJson(`https://i.ibb.co/6Xghf3j/mediafire-startuptalky-2.jpg`)

let fext = res.ext
let flext = fext.toLowerCase();
let ftype = res.filetype
let fltype = ftype.toLowerCase();

            const txt2 = await Void.sendMessage(citel.chat, {image: {url: `https://i.ibb.co/6Xghf3j/mediafire-startuptalky-2.jpg`}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üì¶ M·¥á·¥Ö…™·¥Ä“ì…™ Ä·¥á D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö·¥á Ä ‚¨áÔ∏è_ )* \n\n*‚îÉ‚øª* *üìÑ Íú∞…™ ü·¥á …¥·¥Ä·¥ç·¥á :* ${res.filename}\n\n*‚îÉ‚øª* *‚è≥ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥Ä·¥õ :* ${res.upload_date}\n\n*‚îÉ‚øª* *üìÇ Íú∞…™ ü·¥á ·¥õ è·¥ò·¥á :* ${res.filetype} / ${res.ext}\n\n*‚îÉ‚øª* *üóÉÔ∏è Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB\n\n*‚îÉ‚øª* *üîó Íú∞…™ ü·¥á  ü…™…¥·¥ã :* ${res.url2}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0`}, { quoted: citel });

        await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt2.key,
            } } )

            const txt3 = await Void.sendMessage(citel.chat, {
                    document: {
                        url: res.url,
                    },
                    fileName: res.filename,
                    mimetype: `${fltype}/${flext}`,
                    caption: `_*üìÇ ùô∑ùô¥ùöÅùô¥ ùöàùôæùöÑùöÅ ùôºùô¥ùô≥ùô∏ùô∞ùôµùô∏ùöÅùô¥ ùôµùô∏ùôªùô¥ üìÇ*_\n\n_*‚ùÇ “ì…™ ü·¥á ·¥ú Ä ü :* ${res.url2}_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,
                }, {
                    quoted: citel,
                })
                
                await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt2.key,
            } } )
                
                await Void.sendMessage(citel.chat, { react: {
        text: "üìÇ",
        key: txt3.key,
            } } )
                
                await Void.sendMessage(citel.chat, { react: {
        text: "‚ÑπÔ∏èÔ∏èÔ∏è",
        key: txt2.key,
            } } )
                
                } else {
                    
                   const txt4 = await citel.reply(`_*The is so big.*_‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )
                    
                    }

        }
    )
    
    //---------------------------------------------------------------------------
cmd({
            pattern: "songlist",
            desc: "Downloads audio from youtube.",
            category: "downloader",
            filename: __filename,
            use: '<text>',
        },
        async(Void, citel, text) => {
            if (!text) return citel.reply(`Example : ${prefix + command} Back in black`)
            let yts = require("secktor-pack")
            let search = await yts(text)
            listSerch = []
            teskd = `Result From ${text}.\n_+ ${search.all.length} more results._`
            for (let i of search.all) {
                listSerch.push({
                    title: i.title,
                    rowId: `${prefix}ytmp3 ${i.url}`,
                    description: `Dragon / ${i.timestamp}`
                })
            }
            const sections = [

                {
                    title: "Total Searchüîç" + search.all.length,
                    rows: listSerch
                }

            ]
            const listMessage = {
                text: teskd,
                footer: tlang().footer,
                title: ``,
                buttonText: "Songs",
                mentions: await Void.parseMention(teskd),
                sections
            }
            return Void.sendMessage(citel.chat, listMessage, {
                quoted: citel
            })
        }
    )
    //---------------------------------------------------------------------------
cmd({
            pattern: "yts",
            alias: ["‡∑É‡∑ú‡∂∫‡∂±‡∑ä‡∂±","ytsearch"],
            desc: "Gives descriptive info of query from youtube..",
            react: "üîç",
            category: "downloader",
            filename: __filename,
            use: '<yt search text>',
        },
        async(Void, citel, text) => {
            let yts = require("secktor-pack")
            if (!text) return citel.reply(`_*üñáÔ∏è Give me a YouTube Video Name ‚ùó*_\n*eg:-* _${prefix}yts [video name]_`);
            citel.reply(`üîé _*Searching on YouTube*_ üåé`)
            let search = await yts(text);
            let textt = "*‚îå‚îÄ[üêâDRAGON-MD-V4üêâ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üé• YT SEARCHER ‚ÄçüéûÔ∏è_ )*\n\n*‚îÉ‚øª üîç  è·¥è·¥ú Íú±·¥á·¥Ä Ä·¥Ñ ú·¥á·¥Ö ·¥°·¥è Ä·¥Ö* *"+ text +".*\n\n*‚îÉ‚øª üìù …¥·¥è. ·¥èÍú∞  Ä·¥áÍú±·¥ú ü·¥õÍú±* _"+ search.all.length +"_\n\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ùÇ\n\n";
            let no = 1;
            for (let i of search.all) {
                textt += `‚îè‚îÅ‚îÅ[ _*üåê No : ${no++}*_ ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ\n‚îá\n‚îÉ‚øª   ‚Ñπ Ô∏è·¥õ…™·¥õ ü·¥á : ${i.title}\n‚îÉ_*‚øª   üëÄ ·¥†…™·¥á·¥°Íú± :*_ ${i.views}\n‚îÉ_*‚øª   üïë ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :*_ ${i.timestamp}\n‚îÉ_*‚øª   ‚¨ÜÔ∏èÔ∏èÔ∏èÔ∏è ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥Ö·¥Ä·¥õ·¥á :*_ ${i.ago}\n‚îÉ_*‚øª   üí¨ ·¥Ä·¥ú·¥õ ú·¥è Ä :*_ ${i.author.name}\n‚îÉ_*‚øª   üñáÔ∏è ·¥ú Ä ü :*_ ${i.url}\n‚îá\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ\n\n`;
            }
            return Void.sendMessage(citel.chat, {
                image: {
                    url: search.all[0].thumbnail,
                },
                caption: textt,
            }, {
                quoted: citel,
            });
        }
    )
    //---------------------------------------------------------------------------

cmd({

        pattern: "video",

        alias: ["ytmp4","ytv"], 

        desc: "Downloads audio by yt link.",

        category: "downloader",

        react: "üéûÔ∏è",

        use: '<yt video url>',

    },

    async(Void, citel, text) => {

        let yts = require("secktor-pack");

            let search = await yts(text);

            let anu = search.videos[0];

const apis = await fetchJson(`https://gist.githubusercontent.com/TechwithAmee1/a88de5b36f9d08470149f87fcbaf76fd/raw/15608e9ba09e2fd539738f426049caf2ecefb0a2/data.js`)

const ytdweb = await fetchJson(`https://api-fgmods.ddns.net/api/dowloader/ytdl?url=&apikey=${apis.fgapi}`)

        const getRandom = (ext) => {

            return `${Math.floor(Math.random() * 10000)}${ext}`;

        };

        if (text.length === 0) {

            citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}video [name or link]_`);

            return;

        }

        try {

            let status = ytdweb.status

            if (status = false) {

                citel.reply(`_*‚ùå A Internal Server Error Occured* ‚ùó. *Try again Later*_ üïë.`);

                return;

            }

            let infoYt = await ytdl.getInfo(anu.url);

            //30 MIN

            if (infoYt.videoDetails.lengthSeconds >= videotime) return citel.reply(`*The limit has been exceeded.*‚ùó`);

            let titleYt = infoYt.videoDetails.title;

            if (440 <= dlsize) {

                let yts = require("secktor-pack");

            const txt2 = await Void.sendMessage(citel.chat, {image: {url: anu.thumbnail}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üéûÔ∏è YT DOWNLOADER üé∂_ )* \n\n*‚îÉ‚øª* *üìΩÔ∏è ·¥†…™·¥Ö·¥á·¥è ·¥õ…™·¥õ ü·¥á :* ${anu.title}\n\n*‚îÉ‚øª* *‚è≥ ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :* ${anu.timestamp}\n\n*‚îÉ‚øª* *üëÄ Ô∏è·¥†…™·¥á·¥°Íú± :* ${anu.views}\n\n*‚îÉ‚øª* *üëç  ü…™·¥ã·¥áÍú± :* ${anu.like}\n\n*‚îÉ‚øª* *‚è∞ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥õ…™·¥ç·¥á :* ${anu.ago}\n\n*‚îÉ‚øª* *üóÉÔ∏è ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è :* ${anu.genre}\n\n*‚îÉ‚øª* *üñáÔ∏è ·¥†…™·¥Ö·¥á·¥è  ü…™…¥·¥ã :* ${anu.url}\n\n*‚îÉ‚øª* *üìπ  è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* ${anu.author.name}\n\n*‚îÉ‚øª* *üìé ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™…¥·¥ã :* ${anu.author.url}\n\n*‚îÉ‚øª* *üì∞ ·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :* ${anu.description}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*`}, { quoted: citel })
          
                let search = await yts(text);

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt2.key,
      } } )

const ytdweb = await fetchJson(`https://api-fgmods.ddns.net/api/dowloader/ytdl?url=${anu.url}&apikey=${apis.fgapi}`)

const downloadlink = ytdweb.result.mp4.result
const filesize = ytdweb.result.mp4.size
const vidq = ytdweb.result.mp4.quality

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt2.key,
      } } )

                let buttonMessage = {

                        video: {

                             url: downloadlink ,

                            },

                        mimetype: 'video/mp4',

                        fileName: `${titleYt}.mp4`,

                        caption: `_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è «´·¥ú·¥Ä ü…™·¥õ è :* ${vidq}_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${filesize}_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n\n ${Config.caption}`,

                    }

            const txt3 = await Void.sendMessage(citel.chat, buttonMessage, { quoted: citel })

    await Void.sendMessage(citel.chat, { react: {
        text: "üé•Ô∏è",
        key: txt3.key,
            } } )
    
        await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt2.key,
            } } )

                } else {

                   const txt4 = await citel.reply(`*The limit has been exceeded.*‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )

                }

            } catch (e) {

                console.log(e)

            }

        }

    )

  //---------------------------------------------------------------------------
cmd({
        pattern: "song",
        alias: ["ytmp3","yta"], 
        desc: "Downloads audio by yt link.",
        category: "downloader",
        react: "üé∂",
        use: '<yt video url>',
    },
    async(Void, citel, text) => {
        let yts = require("secktor-pack");

            let search = await yts(text);

            let anu = search.videos[0];
        const getRandom = (ext) => {
            return `${Math.floor(Math.random() * 10000)}${ext}`;
        };

        if (text.length === 0) {
            citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}song [name or link]_`);
            return;
        }
        try {
            let urlYt = text;
            if (!urlYt.startsWith("")) {
                citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}song [name or link]_`);
                return;
            }
            let infoYt = await ytdl.getInfo(anu.url);
            //30 MIN
            if (infoYt.videoDetails.lengthSeconds >= videotime) return citel.reply(`*The limit has been exceeded.*‚ùó`);
            let titleYt = infoYt.videoDetails.title;
            let randomName = getRandom(".mp3");
            const stream = ytdl(anu.url, {
                    filter: (info) => info.audioBitrate == 160 || info.audioBitrate == 128,
                })
                .pipe(fs.createWriteStream(`./${randomName}`));
            await new Promise((resolve, reject) => {
                stream.on("error", reject);
                stream.on("finish", resolve);
            });

            let stats = fs.statSync(`./${randomName}`);
            let fileSizeInBytes = stats.size;
            let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
            if (fileSizeInMegabytes <= dlsize) {
                let yts = require("secktor-pack");
            const txt2 = await Void.sendMessage(citel.chat, {image: {url: anu.thumbnail}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üéûÔ∏è YT DOWNLOADER üé∂_ )* \n\n*‚îÉ‚øª* *üéß ·¥Ä·¥ú·¥Ö…™·¥è ·¥õ…™·¥õ ü·¥á :* ${anu.title}\n\n*‚îÉ‚øª* *‚è≥ ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :* ${anu.timestamp}\n\n*‚îÉ‚øª* üóÉÔ∏è *Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB\n\n*‚îÉ‚øª* *üëÄ Ô∏è·¥†…™·¥á·¥°Íú± :* ${anu.views}\n\n*‚îÉ‚øª* *üëç  ü…™·¥ã·¥áÍú± :* ${anu.like}\n\n*‚îÉ‚øª* *‚è∞ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥õ…™·¥ç·¥á :* ${anu.ago}\n\n*‚îÉ‚øª* *üóÉÔ∏è ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è :* ${anu.genre}\n\n*‚îÉ‚øª* *üñáÔ∏è ·¥†…™·¥Ö·¥á·¥è  ü…™…¥·¥ã :* ${anu.url}\n\n*‚îÉ‚øª* *üìπ  è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* ${anu.author.name}\n\n*‚îÉ‚øª* *üìé ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™…¥·¥ã :* ${anu.author.url}\n\n*‚îÉ‚øª* *üì∞ ·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :* ${anu.description}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*`}, { quoted: citel });

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt2.key,
      } } )
                let search = await yts(text);
                let buttonMessage = {
                        audio: fs.readFileSync(`./${randomName}`),
                        jpegThumbnail: log0,
                        mimetype: 'audio/mpeg',
                        fileName: `${titleYt}.mp3`,
                        caption: `_*‚ùÇ  ·¥Ä·¥ú·¥Ö…™·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB_\n_*‚ùÇ  ·¥Ä·¥ú·¥Ö…™·¥è «´·¥ú·¥Ä ü…™·¥õ è :* 128 kbps_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,
                        headerType: 4,
                        contextInfo: {
                            externalAdReply: {
                            title: titleYt,
                            body: `üê≤ ·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö-·¥†4 üéß`,
                            renderLargerThumbnail: true,
                            thumbnailUrl: search.all[0].thumbnail,
                            mediaUrl: text,
                            mediaType: 1,
                            thumbnail: await getBuffer(search.all[0].thumbnail),
                            sourceUrl: `https://youtube.com/@Dragon-MD-OFC`,
                                    },
                            },
                    }
    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt2.key,
      } } )

            const txt3 = await Void.sendMessage(citel.chat, buttonMessage, { quoted: citel })

    await Void.sendMessage(citel.chat, { react: {
        text: "üéß",
        key: txt3.key,
            } } )
    
        await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt2.key,
            } } )
                } else {
                   const txt4 = await citel.reply(`*The limit has been exceeded.*‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )
                }

                fs.unlinkSync(`./${randomName}`);
            } catch (e) {
                console.log(e)
            }
        }
    )

  //---------------------------------------------------------------------------
cmd({

        pattern: "docsong",

        alias: ["document song"],

        desc: "Downloads audio by yt link.",

        category: "downloader",

        react: "üìÇ",

        use: '<yt video url>',

    },

    async(Void, citel, text) => {

        let yts = require("secktor-pack");

            let search = await yts(text);

            let anu = search.videos[0];

        const getRandom = (ext) => {

            return `${Math.floor(Math.random() * 10000)}${ext}`;

        };

        if (text.length === 0) {

            citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}docsong [name or link]_`);

            return;

        }

        try {

            let urlYt = text;

            if (!urlYt.startsWith("")) {

                citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}docsong [name or link]_`);

                return;

            }

            let infoYt = await ytdl.getInfo(anu.url);

            //30 MIN

            if (infoYt.videoDetails.lengthSeconds >= videotime) return citel.reply(`*The limit has been exceeded.*‚ùó`);

            let titleYt = infoYt.videoDetails.title;

            let randomName = getRandom(".mp3");

            const stream = ytdl(anu.url, {

                    filter: (info) => info.audioBitrate == 160 || info.audioBitrate == 128,

                })

                .pipe(fs.createWriteStream(`./${randomName}`));

            await new Promise((resolve, reject) => {

                stream.on("error", reject);

                stream.on("finish", resolve);

            });

            let stats = fs.statSync(`./${randomName}`);

            let fileSizeInBytes = stats.size;

            let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);

            if (fileSizeInMegabytes <= dlsize) {

                let yts = require("secktor-pack");

            const txt2 = await Void.sendMessage(citel.chat, {image: {url: anu.thumbnail}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üéûÔ∏è YT DOWNLOADER üé∂_ )* \n\n*‚îÉ‚øª* *üéß ·¥Ä·¥ú·¥Ö…™·¥è ·¥õ…™·¥õ ü·¥á :* ${anu.title}\n\n*‚îÉ‚øª* *‚è≥ ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :* ${anu.timestamp}\n\n*‚îÉ‚øª* üóÉÔ∏è *Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB\n\n*‚îÉ‚øª* *üëÄ Ô∏è·¥†…™·¥á·¥°Íú± :* ${anu.views}\n\n*‚îÉ‚øª* *üëç  ü…™·¥ã·¥áÍú± :* ${anu.like}\n\n*‚îÉ‚øª* *‚è∞ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥õ…™·¥ç·¥á :* ${anu.ago}\n\n*‚îÉ‚øª* *üóÉÔ∏è ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è :* ${anu.genre}\n\n*‚îÉ‚øª* *üñáÔ∏è ·¥†…™·¥Ö·¥á·¥è  ü…™…¥·¥ã :* ${anu.url}\n\n*‚îÉ‚øª* *üìπ  è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* ${anu.author.name}\n\n*‚îÉ‚øª* *üìé ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™…¥·¥ã :* ${anu.author.url}\n\n*‚îÉ‚øª* *üì∞ ·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :* ${anu.description}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*`}, { quoted: citel });

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt2.key,
      } } )

                let search = await yts(text);

                let buttonMessage = {

                        document: fs.readFileSync(`./${randomName}`),

                        jpegThumbnail: log0,

                        mimetype: 'audio/mpeg',

                        fileName: `${titleYt}.mp3`,

                        caption: `_*‚ùÇ  ·¥Ä·¥ú·¥Ö…™·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB_\n_*‚ùÇ  ·¥Ä·¥ú·¥Ö…™·¥è «´·¥ú·¥Ä ü…™·¥õ è :* 128 kbps_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,

                        headerType: 4,

                        contextInfo: {
                            externalAdReply: {
                            title: titleYt,
                            body: `üê≤ ·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö-·¥†4 üéß`,
                            renderLargerThumbnail: true,
                            thumbnailUrl: search.all[0].thumbnail,
                            mediaUrl: text,
                            mediaType: 1,
                            thumbnail: await getBuffer(search.all[0].thumbnail),
                            sourceUrl: `https://youtube.com/@Dragon-MD-OFC`,
                                    },
                            },

                    }

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt2.key,
      } } )

            const txt3 = await Void.sendMessage(citel.chat, buttonMessage, { quoted: citel })

    await Void.sendMessage(citel.chat, { react: {
        text: "üéß",
        key: txt3.key,
            } } )
    
        await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt2.key,
            } } )

                } else {

                   const txt4 = await citel.reply(`*The limit has been exceeded.*‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )

                }

                fs.unlinkSync(`./${randomName}`);

            } catch (e) {

                console.log(e)

            }

        }

    )

  //---------------------------------------------------------------------------
cmd({

        pattern: "docvideo",

        alias: ["document video"],

        desc: "Downloads audio by yt link.",

        category: "downloader",

        react: "üìÇ",

        use: '<yt video url>',

    },

    async(Void, citel, text) => {

        let yts = require("secktor-pack");

            let search = await yts(text);

            let anu = search.videos[0];

const apis = await fetchJson(`https://gist.githubusercontent.com/TechwithAmee1/a88de5b36f9d08470149f87fcbaf76fd/raw/15608e9ba09e2fd539738f426049caf2ecefb0a2/data.js`)

const ytdwebs = await fetchJson(`https://api-fgmods.ddns.net/api/dowloader/ytdl?url&apikey=${apis.fgapi}`)

        const getRandom = (ext) => {

            return `${Math.floor(Math.random() * 10000)}${ext}`;

        };

        if (text.length === 0) {

            citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}docvideo [name or link]_`);

            return;

        }

        try {

            let status = ytdwebs.status

            if (status = false) {

                citel.reply(`_*‚ùå A Internal Server Error Occured* ‚ùó. *Try again Later*_ üïë.`);

                return;

            }

            let infoYt = await ytdl.getInfo(anu.url);

            //30 MIN

            if (infoYt.videoDetails.lengthSeconds >= videotime) return citel.reply(`*The limit has been exceeded.*‚ùó`);

            let titleYt = infoYt.videoDetails.title;

            if (440 <= dlsize) {

                let yts = require("secktor-pack");

            const txt2 = await Void.sendMessage(citel.chat, {image: {url: anu.thumbnail}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üéûÔ∏è YT DOWNLOADER üé∂_ )* \n\n*‚îÉ‚øª* *üìΩÔ∏è ·¥†…™·¥Ö·¥á·¥è ·¥õ…™·¥õ ü·¥á :* ${anu.title}\n\n*‚îÉ‚øª* *‚è≥ ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :* ${anu.timestamp}\n\n*‚îÉ‚øª* *üëÄ Ô∏è·¥†…™·¥á·¥°Íú± :* ${anu.views}\n\n*‚îÉ‚øª* *üëç  ü…™·¥ã·¥áÍú± :* ${anu.like}\n\n*‚îÉ‚øª* *‚è∞ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥õ…™·¥ç·¥á :* ${anu.ago}\n\n*‚îÉ‚øª* *üóÉÔ∏è ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è :* ${anu.genre}\n\n*‚îÉ‚øª* *üñáÔ∏è ·¥†…™·¥Ö·¥á·¥è  ü…™…¥·¥ã :* ${anu.url}\n\n*‚îÉ‚øª* *üìπ  è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* ${anu.author.name}\n\n*‚îÉ‚øª* *üìé ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™…¥·¥ã :* ${anu.author.url}\n\n*‚îÉ‚øª* *üì∞ ·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :* ${anu.description}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*`}, { quoted: citel })
          
                let search = await yts(text);

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt2.key,
      } } )

const ytdweb = await fetchJson(`https://api-fgmods.ddns.net/api/dowloader/ytdl?url=${anu.url}&apikey=${apis.fgapi}`)

const downloadlink = ytdweb.result.mp4.result
const filesize = ytdweb.result.mp4.size
const vidq = ytdweb.result.mp4.quality

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt2.key,
      } } )

                let buttonMessage = {

                        document: {

                             url: downloadlink ,

                            },

                        jpegThumbnail: log0,

                        mimetype: 'video/mp4',

                        fileName: `${titleYt}.mp4`,

                        caption: `_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è «´·¥ú·¥Ä ü…™·¥õ è :* ${vidq}_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${filesize}_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,

                        headerType: 4,

                        contextInfo: {
                            externalAdReply: {
                            title: titleYt,
                            body: `üê≤ ·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö-·¥†4 üé•`,
                            renderLargerThumbnail: true,
                            thumbnailUrl: search.all[0].thumbnail,
                            mediaUrl: text,
                            mediaType: 1,
                            thumbnail: await getBuffer(search.all[0].thumbnail),
                            sourceUrl: `https://youtube.com/@Dragon-MD-OFC`,
                                    },
                            },

                    }


            const txt3 = await Void.sendMessage(citel.chat, buttonMessage, { quoted: citel })

    await Void.sendMessage(citel.chat, { react: {
        text: "üé•Ô∏è",
        key: txt3.key,
            } } )
    
        await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt2.key,
            } } )
      
                } else {

                   const txt4 = await citel.reply(`*The limit has been exceeded.*‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )

                }
            } catch (e) {

                console.log(e)

            }

        }

    )
    
cmd({

        pattern: "highvid",

        alias: ["highvideo","videohigh","vidhigh"],

        desc: "Downloads audio by yt link.",

        category: "downloader",

        react: "üéûÔ∏è",

        use: '<yt video url>',

    },

    async(Void, citel, text) => {

        let yts = require("secktor-pack");

            let search = await yts(text);

            let anu = search.videos[0];

        const getRandom = (ext) => {

            return `${Math.floor(Math.random() * 10000)}${ext}`;

        };

        if (text.length === 0) {

            citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}highvideo [name or link]_`);

            return;

        }

        try {

            let urlYt = text;

            if (!urlYt.startsWith("")) {

                citel.reply(`_*üñáÔ∏è Give me a YouTube Link or Name ‚ùó*_\n*eg:-* _${prefix}highvideo [name or link]_`);

                return;

            }

            let infoYt = await ytdl.getInfo(anu.url);

            //30 MIN

            if (infoYt.videoDetails.lengthSeconds >= videotime) return citel.reply(`*The limit has been exceeded.*‚ùó`);

            let titleYt = infoYt.videoDetails.title;

const ytdweb = await fetchJson(`https://darkalphaxteam-api.cyclic.app/api/download/ytmp4?url=${anu.url}&apikey=prabath`)

const vidlink = ytdweb.download

            let fileSizeInBytes = ytdweb.size;

            let fileSizeInMegabytes = fileSizeInBytes / (1024);

            if (fileSizeInMegabytes <= dlsize) {

                let yts = require("secktor-pack");

            const txt2 = await Void.sendMessage(citel.chat, {image: {url: anu.thumbnail}, caption: `\n*‚îè‚îÅ[ _üêâDRAGON-MD-V4üê≤_ ]‚îÄ‚ùÇ*\n\n*‚î£‚îÅ( _üéûÔ∏è YT DOWNLOADER üé∂_ )* \n\n*‚îÉ‚øª* *üìΩÔ∏è ·¥†…™·¥Ö·¥á·¥è ·¥õ…™·¥õ ü·¥á :* ${anu.title}\n\n*‚îÉ‚øª* *‚è≥ ·¥Ö·¥ú Ä·¥Ä·¥õ…™·¥è…¥ :* ${anu.timestamp}\n\n*‚îÉ‚øª* üóÉÔ∏è *Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB\n\n*‚îÉ‚øª* *üëÄ Ô∏è·¥†…™·¥á·¥°Íú± :* ${anu.views}\n\n*‚îÉ‚øª* *üëç  ü…™·¥ã·¥áÍú± :* ${anu.like}\n\n*‚îÉ‚øª* *‚è∞ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö·¥á·¥Ö ·¥õ…™·¥ç·¥á :* ${anu.ago}\n\n*‚îÉ‚øª* *üóÉÔ∏è ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è :* ${anu.genre}\n\n*‚îÉ‚øª* *üñáÔ∏è ·¥†…™·¥Ö·¥á·¥è  ü…™…¥·¥ã :* ${anu.url}\n\n*‚îÉ‚øª* *üìπ  è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü :* ${anu.author.name}\n\n*‚îÉ‚øª* *üìé ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™…¥·¥ã :* ${anu.author.url}\n\n*‚îÉ‚øª* *üì∞ ·¥Ö·¥áÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ :* ${anu.description}\n\n*‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚óÜ*`}, { quoted: citel })

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨áÔ∏è",
        key: txt2.key,
      } } )

                let search = await yts(text);

                let buttonMessage = {

                        document: {

                             url: vidlink ,

                            },

                        jpegThumbnail: log0,

                        mimetype: 'video/mp4',

                        fileName: `${titleYt}.mp4`,

                        caption: `_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è …¥·¥Ä·¥ç·¥á :* ${anu.title}_\n_*‚ùÇ  ·¥†…™·¥Ö·¥á·¥è «´·¥ú·¥Ä ü…™·¥õ è :* 720p_\n_*‚ùÇ  Íú∞…™ ü·¥á Íú±…™·¥¢·¥á :* ${fileSizeInMegabytes} MB_\n\n·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö ‚¶Å ·¥ç·¥Ä·¥Ö·¥á  ô è ·¥Ä·¥ç·¥á·¥áÍú± ú·¥Ä\n·¥†·¥á Ä·¥õ…™·¥è…¥ 4.0\n`,

                        headerType: 4,

                        contextInfo: {
                            externalAdReply: {
                            title: titleYt,
                            body: `üê≤ ·¥Ö Ä·¥Ä…¢·¥è…¥-·¥ç·¥Ö-·¥†4 üé•`,
                            renderLargerThumbnail: true,
                            thumbnailUrl: search.all[0].thumbnail,
                            mediaUrl: text,
                            mediaType: 1,
                            thumbnail: await getBuffer(search.all[0].thumbnail),
                            sourceUrl: `https://youtube.com/@Dragon-MD-OFC`,
                                    },
                            },

                    }

    await Void.sendMessage(citel.chat, { react: {
        text: "‚¨ÜÔ∏è",
        key: txt2.key,
      } } )

            const txt3 = await Void.sendMessage(citel.chat, buttonMessage, { quoted: citel })

    await Void.sendMessage(citel.chat, { react: {
        text: "üé•Ô∏è",
        key: txt3.key,
            } } )
    
        await Void.sendMessage(citel.chat, { react: {
        text: "‚úÖ",
        key: txt2.key,
            } } )

                } else {

                   const txt4 = await citel.reply(`*The limit has been exceeded.*‚ùó`);

                    citel.react("‚ùå");
                    
                    await Void.sendMessage(citel.chat, { react: {
        text: "‚ùå",
        key: txt4.key,
            } } )

                }
            } catch (e) {

                console.log(e)

            }

        }

    )